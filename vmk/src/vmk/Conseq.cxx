/*
 *  Copyright 2007  Janick Bergeron
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

//
// Create a consequence-makefile from a partial parse tree
//

#include <stdio.h>
#include <string.h>


#include "globals.hxx"
#include "Conseq.hxx"


//
// A "consequence" makefile has the dependencies in
// reverse: froma file, we can know which files
// will need to be recompiled.
//
// Doing a 'make -n' usign the normal makefile
// could have worked but that would have listed
// all files that needed to be recompiled, not
// just the ones depending on the one specified.
//
// We also want ot be able to run this even if
// the current view is up-to-date so we know what
// we'll need to check-out in an automated build
// environment.
//

Consequence::Consequence(const char* fileName,
                         LibraryHashTable* libs)
{
    //
    // Write the Makefile
    //
    FILE* mkf;
    if (strcmp(fileName, "-") == 0) mkf = stdout;
    else mkf = fopen(fileName, "w");
    if (mkf == NULL) {
	fprintf(stderr, "Cannot open \"%s\" for writing:", fileName);
	perror("");
        exitCode = -1;
	return;
    }

    // Banner
    fprintf(mkf, "# Consequence makefile generated by VMK %1.3f\n\n", version);

    // For each file in each library included
    // in the makefile, record a consequence
    // on each file that it depends on.
    {
	LibraryHashTableIter scanLibs(libs);
	for (scanLibs.reset(); scanLibs.key(); ++scanLibs) {
	    if (!scanLibs.entry()->inMakefile()) continue;
            
            // Skip aliases
            if (strcmp(scanLibs.entry()->getName(), scanLibs.key()) != 0) continue;
            
	    SourceFileIter scanFiles(*scanLibs.entry());
	    for (scanFiles.reset(); scanFiles(); ++scanFiles) {

                if (debugLevel > 4) {
                    printf("Finding consequences for file %s\n",
                           scanFiles()->getName());
                }
                
		SourceFileUnitIter scanUnits(*scanFiles());
		for (scanUnits.reset(); scanUnits(); ++scanUnits) {

                    LibraryUnit* parent = scanUnits()->getParent();
                    if (parent != NULL) {
                        if (debugLevel > 4) {
                            printf("%s has a consequence on %s\n",
                                   parent->getSourceFile()->getName(),
                                   scanFiles()->getName());
                        }

                        parent->getSourceFile()->addConsequence(scanFiles());
                    };

                    LibraryUnitDependsIter scanDepends(scanUnits());
                    for (scanDepends.reset(); scanDepends(); ++scanDepends) {
                        LibraryUnit* unit;

                        unit = scanDepends()->getUnit();
                        if (unit == NULL) continue;

                        if (debugLevel > 4) {
                            printf("%s has a consequence on %s\n",
                                   unit->getSourceFile()->getName(),
                                   scanFiles()->getName());
                        }

                        unit->getSourceFile()->addConsequence(scanFiles());
                    }
		}
	    }
	}
        fprintf(mkf, "\n\n");
    }

    // For each file in each library included
    // in the makefile, write-out a dependency rule
    // based on its consequences
    {
	LibraryHashTableIter scanLibs(libs);
	for (scanLibs.reset(); scanLibs.key(); ++scanLibs) {
	    if (!scanLibs.entry()->inMakefile()) continue;
            
            // Skip aliases
            if (strcmp(scanLibs.entry()->getName(), scanLibs.key()) != 0) continue;
            
	    SourceFileIter scanFiles(*scanLibs.entry());
	    for (scanFiles.reset(); scanFiles(); ++scanFiles) {

                fprintf(mkf, "\n%s: force", scanFiles()->getName());
                
		SourceFileConseqIter scanConseq(*scanFiles());
		for (scanConseq.reset(); scanConseq(); ++scanConseq) {
                    fprintf(mkf, " \\\n    %s", scanConseq()->getName());
		}
                fprintf(mkf, "\n\t@echo %s\n", scanFiles()->getName());
	    }
	}
        fprintf(mkf, "\nforce:\n\n");
    }

    fclose(mkf);
}

Consequence::~Consequence()
{}
